441*4
tic
write.csv(df, file = paste0(getwd(), "/simOutput.csv"))
View(df)
mainGrid <- expand.grid(.n = c(100, 500, 1000),
.p = c(10, 50, 100, 200),
.cvType = c("boot", "cv5", "cv10"),
stringsAsFactors = FALSE)
results <- matrix(NA, nrow = dim(mainGrid)[1], ncol = 4) %>% as.data.frame()
names(results) <- c("RMSE", "Rsq", "RMSEsd", "R2sd")
tic <- proc.time()
for (row in 1:nrow(mainGrid)){
n = mainGrid[row,".n"]
p = mainGrid[row,".p"]
cvi = mainGrid[row,".cvType"]
# ki = mainGrid[row,".k"]
set.seed(1)
dataMat <- makeData(observations = n,predictors = p)
fit.out <- MLpipeline(dataMat, cvType = cvi)
results[row,"RMSE"] <- fit.out[2]
results[row,"Rsq"] <- fit.out[3]
if (cvi != "nocv"){
results[row,"RMSEsd"] <- fit.out[4]
}
if (cvi != "nocv"){
results[row,"R2sd"] <- fit.out[5]
}
proc.time() - tic
df <- cbind(mainGrid, results) %>% as.data.frame()
write.csv(df, file = paste0(getwd(), "/simOutput.csv"))
teresa <- makeData(300,25)
fit.loo <- MLpipeline(teresa, cvType = "loo")
fit.loo
fit.5 <- MLpipeline(teresa, cvType = "cv5")
fit.5
View(results)
View(df)
library("ggplot")
library("ggplot2")
ggplot(aes(x=p, y=RMSE, fill = .n)) + geom_line()
str(df)
ggplot(df, aes(x=p, y=RMSE, fill = .n)) + geom_line()
ggplot(df, aes(x=.p, y=RMSE, fill = .n)) + geom_line()
ggplot(df, aes(x=.p, y=RMSE, fill = .n)) + geom_scatter()
ggplot(df, aes(x=.p, y=RMSE, fill = .n)) + geom_point()
142/5
46/5
72/5
102/7
28.4+9.2+14.4
(142/5) + (46/5) + (72/5)
142-52
46-52
-52 -52
+20 +90
-6
-52 -52 +20 +90 -6
90-6
20-51
20-52
?expand.grid
ggplot(df, aes(x=.p, y=RMSE, fill = .n)) + geom_line() + facet_grid(~ .cvType)
ggplot(df, aes(x=.p, y=RMSE, fill = .n)) + geom_jitter() + facet_grid(~ .cvType)
ggplot(df, aes(x=.p, y=RMSE, colour = .n)) + geom_jitter() + facet_grid(~ .cvType)
ggplot(df, aes(x=.p, y=RMSE, colour = .n)) + geom_line() + facet_grid(~ .cvType)
df$.n <- as.factor(df$.n)
ggplot(df, aes(x=.p, y=RMSE, colour = .n)) + geom_jitter() + facet_grid(~ .cvType)
ggplot(df, aes(x=.p, y=RMSE, colour = .n)) + geom_line() + facet_grid(~ .cvType)
mainGrid <- expand.grid(.n = c(10, 25, 50, 100, 200, 400, 500, 1000, 1500),
.p = c(10, 50, 100, 200),
.cvType = c("boot", "cv5", "cv10"),
stringsAsFactors = FALSE)
results <- matrix(NA, nrow = dim(mainGrid)[1], ncol = 4) %>% as.data.frame()
names(results) <- c("RMSE", "Rsq", "RMSEsd", "R2sd")
tic <- proc.time()
for (row in 1:nrow(mainGrid)){
n = mainGrid[row,".n"]
p = mainGrid[row,".p"]
cvi = mainGrid[row,".cvType"]
# ki = mainGrid[row,".k"]
set.seed(1)
dataMat <- makeData(observations = n,predictors = p)
fit.out <- MLpipeline(dataMat, cvType = cvi)
results[row,"RMSE"] <- fit.out[2]
results[row,"Rsq"] <- fit.out[3]
if (cvi != "nocv"){
results[row,"RMSEsd"] <- fit.out[4]
}
if (cvi != "nocv"){
results[row,"R2sd"] <- fit.out[5]
}
mainGrid <- expand.grid(.n = c(10, 25, 50, 100, 200, 400, 500, 1000, 1500),
.p = c(10, 50, 100, 200),
.cvType = c("boot", "cv5", "cv10"),
stringsAsFactors = FALSE)
results <- matrix(NA, nrow = dim(mainGrid)[1], ncol = 4) %>% as.data.frame()
names(results) <- c("RMSE", "Rsq", "RMSEsd", "R2sd")
tic <- proc.time()
for (row in 1:nrow(mainGrid)){
n = mainGrid[row,".n"]
p = mainGrid[row,".p"]
cvi = mainGrid[row,".cvType"]
# ki = mainGrid[row,".k"]
set.seed(1)
dataMat <- makeData(observations = n,predictors = p)
fit.out <- MLpipeline(dataMat, cvType = cvi)
results[row,"RMSE"] <- fit.out[2]
results[row,"Rsq"] <- fit.out[3]
if (cvi != "nocv"){
results[row,"RMSEsd"] <- fit.out[4]
}
if (cvi != "nocv"){
results[row,"R2sd"] <- fit.out[5]
}
proc.time() - tic
df <- cbind(mainGrid, results) %>% as.data.frame()
write.csv(df, file = paste0(getwd(), "/simOutput.csv"))
View(df)
df$.n <- as.factor(df$.n)
ggplot(df, aes(x=.p, y=RMSE, colour = .n)) + geom_line() + facet_grid(~ .cvType)
View(df)
df[92,"RMSE"] <- 300
df[48,"RMSE"] <- 300
ggplot(df, aes(x=.p, y=RMSE, colour = .n)) + geom_line() + facet_grid(~ .cvType)
oneSim <- function(grid,MCnum, ... ){
MCout <- list()
for (MC in MCnum){
simResult <- matrix(NA, nrow = dim(mainGrid)[1], ncol = 4) %>% as.data.frame()
names(SimResult) <- c("RMSE", "Rsq", "RMSEsd", "R2sd")
for (row in 1:nrow(mainGrid)){
n = mainGrid[row,".n"]
p = mainGrid[row,".p"]
cvi = mainGrid[row,".cvType"]
# ki = mainGrid[row,".k"]
set.seed(MC)
dataMat <- makeData(observations = n,predictors = p)
fit.out <- MLpipeline(dataMat, cvType = cvi)
simResult[row,"RMSE"] <- fit.out[2]
simResult[row,"Rsq"] <- fit.out[3]
if (cvi != "nocv"){
simResult[row,"RMSEsd"] <- fit.out[4]
}
if (cvi != "nocv"){
simResult[row,"R2sd"] <- fit.out[5]
}
simOut <- cbind(mainGrid, simOut) %>% as.data.frame()
MCout[[MC]] <- simOut
}
return(MCout)
}
mc.grid <- expand.grid(.n = c(400, 1000, 1500),
.p = c(10, 50),
.cvType = c("cv5", "cv10"),
stringsAsFactors = FALSE)
oneSim <- function(grid,MCnum, ... ){
MCout <- list()
for (MC in MCnum){
simResult <- matrix(NA, nrow = dim(mainGrid)[1], ncol = 4) %>% as.data.frame()
names(SimResult) <- c("RMSE", "Rsq", "RMSEsd", "R2sd")
for (row in 1:nrow(mainGrid)){
n = mainGrid[row,".n"]
p = mainGrid[row,".p"]
cvi = mainGrid[row,".cvType"]
# ki = mainGrid[row,".k"]
set.seed(MC)
dataMat <- makeData(observations = n,predictors = p)
fit.out <- MLpipeline(dataMat, cvType = cvi)
simResult[row,"RMSE"] <- fit.out[2]
simResult[row,"Rsq"] <- fit.out[3]
if (cvi != "nocv"){
simResult[row,"RMSEsd"] <- fit.out[4]
}
if (cvi != "nocv"){
simResult[row,"R2sd"] <- fit.out[5]
}
simOut <- cbind(mainGrid, simOut) %>% as.data.frame()
MCout[[MC]] <- simOut
}
return(MCout)
}
test <- oneSim(mc.grid, 2)
oneSim <- function(grid,MCnum, ... ){
MCout <- list()
for (MC in MCnum){
simResult <- matrix(NA, nrow = dim(mainGrid)[1], ncol = 4) %>% as.data.frame()
names(simResult) <- c("RMSE", "Rsq", "RMSEsd", "R2sd")
for (row in 1:nrow(mainGrid)){
n = mainGrid[row,".n"]
p = mainGrid[row,".p"]
cvi = mainGrid[row,".cvType"]
# ki = mainGrid[row,".k"]
set.seed(MC)
dataMat <- makeData(observations = n,predictors = p)
fit.out <- MLpipeline(dataMat, cvType = cvi)
simResult[row,"RMSE"] <- fit.out[2]
simResult[row,"Rsq"] <- fit.out[3]
if (cvi != "nocv"){
simResult[row,"RMSEsd"] <- fit.out[4]
}
if (cvi != "nocv"){
simResult[row,"R2sd"] <- fit.out[5]
}
simOut <- cbind(mainGrid, simOut) %>% as.data.frame()
MCout[[MC]] <- simOut
}
return(MCout)
}
test <- oneSim(mc.grid, 2)
mc.grid <- expand.grid(.n = c(400, 1000, 1500),
.p = c(10, 50),
.cvType = c("cv5", "cv10"),
stringsAsFactors = FALSE)
oneSim <- function(grid,MCnum, ... ){
MCout <- list()
for (MC in MCnum){
simResult <- matrix(NA, nrow = dim(mainGrid)[1], ncol = 4) %>% as.data.frame()
names(simResult) <- c("RMSE", "Rsq", "RMSEsd", "R2sd")
for (row in 1:nrow(mainGrid)){
n = mainGrid[row,".n"]
p = mainGrid[row,".p"]
cvi = mainGrid[row,".cvType"]
# ki = mainGrid[row,".k"]
set.seed(MC)
dataMat <- makeData(observations = n,predictors = p)
fit.out <- MLpipeline(dataMat, cvType = cvi)
simResult[row,"RMSE"] <- fit.out[2]
simResult[row,"Rsq"] <- fit.out[3]
if (cvi != "nocv"){
simResult[row,"RMSEsd"] <- fit.out[4]
}
if (cvi != "nocv"){
simResult[row,"R2sd"] <- fit.out[5]
}
simOut <- cbind(mainGrid, simResult) %>% as.data.frame()
MCout[[MC]] <- simOut
}
return(MCout)
}
test <- oneSim(mc.grid, 2)
View(test[[1]])
View(test[[2]])
mc.grid <- expand.grid(.n = c(400, 1000, 1500),
.p = c(10, 50),
.cvType = c("cv5", "cv10"),
stringsAsFactors = FALSE)
oneSim <- function(grid,MCnum, ... ){
MCout <- list()
for (MC in 1:MCnum){
simResult <- matrix(NA, nrow = dim(mainGrid)[1], ncol = 4) %>% as.data.frame()
names(simResult) <- c("RMSE", "Rsq", "RMSEsd", "R2sd")
for (row in 1:nrow(mainGrid)){
n = mainGrid[row,".n"]
p = mainGrid[row,".p"]
cvi = mainGrid[row,".cvType"]
# ki = mainGrid[row,".k"]
set.seed(MC)
dataMat <- makeData(observations = n,predictors = p)
fit.out <- MLpipeline(dataMat, cvType = cvi)
simResult[row,"RMSE"] <- fit.out[2]
simResult[row,"Rsq"] <- fit.out[3]
if (cvi != "nocv"){
simResult[row,"RMSEsd"] <- fit.out[4]
}
if (cvi != "nocv"){
simResult[row,"R2sd"] <- fit.out[5]
}
simOut <- cbind(mainGrid, simResult) %>% as.data.frame()
MCout[[MC]] <- simOut
}
return(MCout)
}
test <- oneSim(mc.grid, 2)
test[[1]] %>% View
test[[s]] %>% View
test[[2]] %>% View
mc.rmse <- mean(test[[1]]$RMSE, test[[2]]$RMSE)
test[[1]]$RMSE
mc.rmse <- cbind(test[[1]]$RMSE, test[[2]]$RMSE) %>% rowSums()
df <- cbind(mc.grid, mc.rmse)
df$.n <- as.factor(df$.n)
ggplot(df, aes(x=.p, y=RMSE, colour = .n)) + geom_line() + facet_grid(~ .cvType)
str(df)
str(mc.grid)
mc.rmse <- cbind(test[[1]]$RMSE, test[[2]]$RMSE) %>% rowSums()
df <- cbind(mc.grid, mc.rmse)
df$.n <- as.factor(df$.n)
ggplot(df, aes(x=.p, y=mc.rmse, colour = .n)) + geom_line() + facet_grid(~ .cvType)
df %>% View
test[[1]]$RMSE
set.seed(1); MLpipeline(makeData(1000,10), cvType = "cv10")
set.seed(2); MLpipeline(makeData(1000,10), cvType = "cv10")
mc.grid <- expand.grid(.n = c(400, 1000, 1500),
.p = c(10, 50),
.cvType = c("cv5", "cv10"),
stringsAsFactors = FALSE)
oneSim <- function(grid,MCnum, ... ){
MCout <- list()
for (MC in 1:MCnum){
simResult <- matrix(NA, nrow = dim(grid)[1], ncol = 4) %>% as.data.frame()
names(simResult) <- c("RMSE", "Rsq", "RMSEsd", "R2sd")
for (row in 1:nrow(grid)){
n = grid[row,".n"]
p = grid[row,".p"]
cvi = grid[row,".cvType"]
set.seed(MC)
dataMat <- makeData(observations = n,predictors = p)
fit.out <- MLpipeline(dataMat, cvType = cvi)
simResult[row,"RMSE"] <- fit.out[2]
simResult[row,"Rsq"] <- fit.out[3]
if (cvi != "nocv"){
simResult[row,"RMSEsd"] <- fit.out[4]
}
if (cvi != "nocv"){
simResult[row,"R2sd"] <- fit.out[5]
}
simOut <- cbind(grid, simResult) %>% as.data.frame()
MCout[[MC]] <- simOut
}
return(MCout)
}
test <- oneSim(mc.grid, 2)
mc.rmse <- cbind(test[[1]]$RMSE, test[[2]]$RMSE) %>% rowSums()
df <- cbind(mc.grid, mc.rmse)
df$.n <- as.factor(df$.n)
ggplot(df, aes(x=.p, y=mc.rmse, colour = .n)) + geom_line() + facet_grid(~ .cvType)
test[[1]] %>% View
set.seed(1); MLpipeline(makeData(1000,10), cvType = "cv10")
set.seed(2); MLpipeline(makeData(1000,10), cvType = "cv10")
test[[2]] %>% View
set.seed(2); MLpipeline(makeData(1000,10), modelType = "ridge", cvType = "cv10")
set.seed(2); MLpipeline(makeData(1000,10), modelType = "ridge", cvType = "cv10") %>% str()
```{r}
MLpipeline <- function(data, modelType = "lm", cvType, k=NA, perfMet = "RMSE"   ,...){
## One line ML pipeline
## Will train and test a model according to the instructions/CV set up provided
# Data should be a matrix, with the first column the predictor
# model should be from this list: http://topepo.github.io/caret/modelList.html
# cvTypes: "cv" (provide k); "loo"; "boot" (default 25 bootstraps); "nocv"
#          "cv5" (5-fold); "cv10" (10-fold)
# perfMet is the desired performance metric (defaults to RMSE)
# Error handling (lol)
if((cvType %in% c("cv", "loo", "boot", "nocv", "cv5", "cv10")) == FALSE){
stop("you need to provide a cv method that I have pre-coded")
}
if((cvType == "cv") & (is.na(k) == TRUE)){
stop("you asked for cv but didnt provide k")
if((is.numeric(k) == FALSE) | (k <= 1)){
stop("k needs to be a number, greater than 1")
}
# Format data
Yvec <- data[,1]  %>% as.vector()
Xmat <- data[,-1] %>% as.matrix()
# Initialise Cross-Validation
if (cvType == "cv"){
tcontrol <- trainControl(method = "cv", number = k)
} else if (cvType == "cv5"){
tcontrol <- trainControl(method = "cv", number = 5)
} else if (cvType == "cv10"){
tcontrol <- trainControl(method = "cv", number = 10)
} else if (cvType == "loo"){
tcontrol <- trainControl(method = "LOOCV")
} else if (cvType == "boot"){
tcontrol <- trainControl(method = "boot")
} else if (cvType == "nocv"){
tcontrol <- trainControl(method = "none")
}
# Fit the model
fit <- train(x = Xmat, y = Yvec,
method = modelType,
metric = perfMet,
trControl = tcontrol)
out <- fit$results %>% as.vector()
# Results format will vary depending on the modelType
if (modelType == "ridge"){
out <- out[out$RMSE == min(out$RMSE),]
}
return(out)
}
set.seed(2); MLpipeline(makeData(1000,10), modelType = "ridge", cvType = "cv10") %>% str()
mc.grid <- expand.grid(.n = c(40, 100, 150),
.p = c(25, 50, 100),
.cvType = c("cv5", "cv10"),
stringsAsFactors = FALSE)
oneSim <- function(grid,MCnum, ... ){
MCout <- list()
for (MC in 1:MCnum){
simResult <- matrix(NA, nrow = dim(grid)[1], ncol = 4) %>% as.data.frame()
names(simResult) <- c("RMSE", "Rsq", "RMSEsd", "R2sd")
for (row in 1:nrow(grid)){
n = grid[row,".n"]
p = grid[row,".p"]
cvi = grid[row,".cvType"]
set.seed(MC)
dataMat <- makeData(observations = n,predictors = p)
fit.out <- MLpipeline(dataMat, cvType = cvi)
simResult[row,"RMSE"] <- fit.out[2]
simResult[row,"Rsq"] <- fit.out[3]
if (cvi != "nocv"){
simResult[row,"RMSEsd"] <- fit.out[4]
}
if (cvi != "nocv"){
simResult[row,"R2sd"] <- fit.out[5]
}
simOut <- cbind(grid, simResult) %>% as.data.frame()
MCout[[MC]] <- simOut
}
return(MCout)
}
test <- oneSim(mc.grid, 2)
mc.rmse <- cbind(test[[1]]$RMSE, test[[2]]$RMSE) %>% rowSums()
df <- cbind(mc.grid, mc.rmse)
df$.n <- as.factor(df$.n)
ggplot(df, aes(x=.p, y=mc.rmse, colour = .n)) + geom_line() + facet_grid(~ .cvType)
test[[1]] %>% View
test[[2]] %>% View
set.seed(2); MLpipeline(makeData(40,100), cvType = "cv5") %>% str()
mc.grid <- expand.grid(.n = c(40, 100, 150),
.p = c(25, 50, 100),
.cvType = c("cv5", "loo"),
stringsAsFactors = FALSE)
oneSim <- function(grid,MCnum, ... ){
MCout <- list()
for (MC in 1:MCnum){
simResult <- matrix(NA, nrow = dim(grid)[1], ncol = 4) %>% as.data.frame()
names(simResult) <- c("RMSE", "Rsq", "RMSEsd", "R2sd")
for (row in 1:nrow(grid)){
n = grid[row,".n"]
p = grid[row,".p"]
cvi = grid[row,".cvType"]
set.seed(MC)
dataMat <- makeData(observations = n,predictors = p)
fit.out <- MLpipeline(dataMat, cvType = cvi)
simResult[row,"RMSE"] <- fit.out[2]
simResult[row,"Rsq"] <- fit.out[3]
if (cvi != "nocv"){
simResult[row,"RMSEsd"] <- fit.out[4]
}
if (cvi != "nocv"){
simResult[row,"R2sd"] <- fit.out[5]
}
simOut <- cbind(grid, simResult) %>% as.data.frame()
MCout[[MC]] <- simOut
}
return(MCout)
}
test <- oneSim(mc.grid, 2)
mc.rmse <- cbind(test[[1]]$RMSE, test[[2]]$RMSE) %>% rowSums()
df <- cbind(mc.grid, mc.rmse)
df$.n <- as.factor(df$.n)
ggplot(df, aes(x=.p, y=mc.rmse, colour = .n)) + geom_line() + facet_grid(~ .cvType)
set.seed(2); MLpipeline(makeData(40,99), cvType = "cv5") %>% str()
set.seed(2); MLpipeline(makeData(40,100), cvType = "cv5") %>% str()
set.seed(2); MLpipeline(makeData(40,101), cvType = "cv5") %>% str()
40/5
set.seed(2); makeData(40,100) %>% View
set.seed(2); t <- makeData(40,100)
cor(t$Y, t$V100)
str(t)
cor(t[,1], t[,101])
cor(t[,1], [t,-1])
cor(t[,1], t[],-1])
cor(t[,1], t[,-1])
cor(t[,1], t[,-1]) %>% dim(0)
cor(t[,1], t[,-1]) %>% dim()
cor(t[,1], t[,-1]) %>% as.vector()
cor(t[,1], t[,-1]) %>% as.vector() %>% View
cor(t[,1], t[,-1]) %>% as.vector() %>% summary()
detectCores()
install.packages("foreach")
install.packages("iterators")
detectCores()
library(foreach)
detectCores()
library(doMC)
detectCores()
set.seed(1)
rep(1:100)
library(dplyr)
target <- 1:100
library(permute)
target[shuffle(100)]
set.seed(1)
target[shuffle(100)]
set.seed(1)
target[shuffle(100)]
164+200+258
622-6
version
?update.R()
install.packages("lsmeans")
setwd("~/Documents/PhD/PhD_Core/Teaching/MLworkshop/dukeWorkshop")
# Load libraries
libs <- c("dplyr", "ggplot2", "RColorBrewer", "glmnet", "caret", "pROC", "permute", "gbm",
"klaR", "plyr", "foreach", "doMC")
lapply(libs, require, character.only = TRUE)
registerDoMC(detectCores()-1)
## Read in (training) data
#     Data contains freesurfer output, along with age and gender, for a bunch
#     of people scanned in the Boston area over the last couple of years.
raw <- read.csv("data/workshopTrain.csv", as.is=TRUE)
raw$X <- NULL
raw$Sex <- as.factor(raw$Sex)
df <- raw[,-1]
## View data in Rstudio
View(df)
## View top of data frame in console
head(df[,1:8])
## Any missing data?
complete.cases(df) %>% table()
## View ICV by gender
ggplot(data = df, aes(ICV, colour = Sex)) +
geom_freqpoly()
